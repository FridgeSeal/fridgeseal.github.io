<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title> - distributed-systems</title>
    <link href="https://fridgeseal.github.io/tags/distributed-systems/atom.xml" rel="self" type="application/atom+xml"/>
    <link href="https://fridgeseal.github.io"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2023-11-12T00:00:00+00:00</updated>
    <id>https://fridgeseal.github.io/tags/distributed-systems/atom.xml</id>
    <entry xml:lang="en">
        <title> Better Operators - Or, sharing state but it&#x27;s fun</title>
        <published>2023-11-11T00:00:00+00:00</published>
        <updated>2023-11-12T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://fridgeseal.github.io/half_formed_ideas/better-operators/" type="text/html"/>
        <id>https://fridgeseal.github.io/half_formed_ideas/better-operators/</id>
        
        <content type="html">&lt;h2 id=&quot;background&quot;&gt;Background&lt;&#x2F;h2&gt;
&lt;p&gt;I’ve recently been writing a Kubernetes Operator for work, and the experience has been &lt;em&gt;incredibly&lt;&#x2F;em&gt; fun, and weirdly inspiring. It’s like a complete inversion of the “normal” way we build (web&#x2F;client-server) applications, and I think there’s some &lt;em&gt;really, really&lt;&#x2F;em&gt; powerful software-architectural ideas lurking in there which are probably being ignored because of the stigma of being attached to K8s, or because “they’re just some weird thingy K8s does”.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;underlying-theory&quot;&gt;&lt;a href=&quot;https:&#x2F;&#x2F;fridgeseal.github.io&#x2F;half_formed_ideas&#x2F;better-operators&#x2F;#underlying-theory&quot;&gt;Underlying theory&lt;&#x2F;a&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;The “normal” architecture and design principles for web services is something along the lines of:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;REST&#x2F;HTTP API, GRPC if you’re lucky&lt;&#x2F;li&gt;
&lt;li&gt;Create &#x2F; Read &#x2F; Update &#x2F; Delete API’s as standard&lt;&#x2F;li&gt;
&lt;li&gt;Some designs favour CQRS which exhibits “read-write separation”.&lt;&#x2F;li&gt;
&lt;li&gt;The database is your &lt;em&gt;private&lt;&#x2F;em&gt; store of data.&lt;&#x2F;li&gt;
&lt;li&gt;DB’s will be OLTP - as actions will be reading and mutating specific rows.&lt;&#x2F;li&gt;
&lt;li&gt;The API you expose is the “contract” with consuming applications.
Architecturally, it’s all very “imperative”, we perform actions and drive through state machines by holding some data and progressively mutating it. Compare this with a “message passing” or “event driven” style architecture, which is more “functional” in it’s design.&lt;br &#x2F;&gt;
Rather than holding state and mutating it according to data we send&#x2F;receive, we receive some data, try and perform &lt;em&gt;our&lt;&#x2F;em&gt; actions on it, and then pass it along to your consumers, or some kind of event stream (a la Kafka). In an imperative&#x2F;OOP-style architecture, you make a request to some service, await a response and perform mutations to your object-of-responsibility accordingly. The equivalent in event-driven&#x2F;message-passing land is passing it off as a message to the relevant consumer, and awaiting a message on &lt;em&gt;your&lt;&#x2F;em&gt; incoming channels indicating that message &lt;code&gt;id: x&lt;&#x2F;code&gt; finished {successfully, errored}. The best designers will mix-and-match the best of these direct&#x2F;message-passing API’s in their software according to the ideal semantics of their desired system.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;There’s a &lt;em&gt;lot&lt;&#x2F;em&gt; written about event-driven systems in software design. I think the first 15% of it is generated by Confluent trying to get people to use Kafka, and the rest is garbage-quality-Medium-blogspam, which really makes finding anything but the most introductory content difficult.&lt;&#x2F;p&gt;
&lt;p&gt;Most content about event-driven systems - at least within the spaces I move in - are about &lt;code&gt;edge triggered&lt;&#x2F;code&gt; systems, but there’s another variant &lt;code&gt;level-triggered&lt;&#x2F;code&gt; systems. The former is what you are probably most familiar with if you’ve encountered event-driven systems before: you do work when you &lt;em&gt;receive&lt;&#x2F;em&gt; the message. This is in contrast with &lt;code&gt;level-triggered&lt;&#x2F;code&gt; event system, in which &lt;em&gt;you do work while something is in a particular state&lt;&#x2F;em&gt;. I understand the latter is common in electrical engineering.&lt;&#x2F;p&gt;
&lt;p&gt;Kubernetes (henceforth K8s) uses a level-triggered system - controllers are invoked on the resources they manage, while those resources are in non-stable&#x2F;non-terminal states&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;, and this is where the particularly interesting parts come in.&lt;&#x2F;p&gt;
&lt;p&gt;In K8s, you define what you want to run in the cluster, by writing up some horridly-verbose &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;kubernetes.io&#x2F;docs&#x2F;concepts&#x2F;workloads&#x2F;controllers&#x2F;deployment&#x2F;&quot;&gt;yaml&lt;&#x2F;a&gt;, which gets quickly validated, before being written into &lt;code&gt;etcd&lt;&#x2F;code&gt; - K8s persistent, distributed KV-Store. When this write happens, the deployment controller is “woken up” and it’ll read the &lt;code&gt;Deployment&lt;&#x2F;code&gt; yaml configs, attempt to make everything in there a reality, and then go back to sleep, this is known as the &lt;code&gt;reconciliation loop&lt;&#x2F;code&gt;. There’s some important differences with your normal CRUD app here:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;if a reconciliation loop fails, a controller &lt;em&gt;does not&lt;&#x2F;em&gt; attempt to rollback and cleanup.
&lt;ul&gt;
&lt;li&gt;instead, we simply mark it as failed, go back to sleep and try again later. This is because we might have “failed” for a few reason, and trying again might fix these. Ordering issues, pushing a deployment before the container was available, not fitting onto any existing machine and needing to wait for a new instance to come up are all valid examples of this.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;This radically simplifies a number of things:
&lt;ul&gt;
&lt;li&gt;we are explicitly expected to be able to deal with broken and degraded resources.&lt;&#x2F;li&gt;
&lt;li&gt;we don’t have issues with failed rollouts&#x2F;rollbacks causing invalid data or violating invariants.&lt;&#x2F;li&gt;
&lt;li&gt;It automatically gives us a nice way to handle ordering conflicts: simply roll everything out declaratively, and then anything that requires the existence of some other resource to be ready, will simply converge once all the conditions are met.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Similarly, making a change or deleting your resource  simply updates the resource in &lt;code&gt;etcd&lt;&#x2F;code&gt; and kicks off the wake-up-and-reconcile process.&lt;&#x2F;p&gt;
&lt;p&gt;Operators&#x2F;controllers often update these CRD resources back - often mostly via their &lt;code&gt;Status&lt;&#x2F;code&gt; objects, but sometimes directly&lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt; - in order to “fill in” optional information that the client didn’t provide.&lt;&#x2F;p&gt;
&lt;p&gt;This is where things get interesting. Viewed a certain way, this is a bit like a reversal of the normal CRUD architecture: operators are nominally stateless, relying &lt;em&gt;only&lt;&#x2F;em&gt; on the d&lt;&#x2F;p&gt;
&lt;h3 id=&quot;footnotes&quot;&gt;&lt;a href=&quot;https:&#x2F;&#x2F;fridgeseal.github.io&#x2F;half_formed_ideas&#x2F;better-operators&#x2F;#footnotes&quot;&gt;Footnotes&lt;&#x2F;a&gt;&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;This is &lt;em&gt;really&lt;&#x2F;em&gt; glossing over some stuff about how K8s works, but this is at least the design intent.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Adding finalizers to “yourself” (the CRD) is a common example of this; In general though, you have to be careful, because without care, you can end up in a self-invocation-death-spiral.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
        
    </entry>
</feed>
